#pragma config(Sensor, dgtl1,  encR,           sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encL,           sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  gripperBottom,  sensorDigitalOut)
#pragma config(Sensor, dgtl7,  baseL,          sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  baseR,          sensorQuadEncoder)
#pragma config(Sensor, dgtl11, limitDR,        sensorTouch)
#pragma config(Sensor, dgtl12, limitArms,      sensorTouch)
#pragma config(Motor,  port1,           armL,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           gripperBottom, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rbBase,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rfBase,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           lbBase,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           lfBase,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           DRLU,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           DRRU,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          armR,          tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "BNSLib.h";

// Status para cada proceso
float armStat;
float baseStat;
bool topOpen;
bool bottomOpen;

// Targets para procesos
float baseTarget;
float armTarget;
float armSpeed;
float baseSpeed;

// anadir sistema de ambos brazos

// VexRT(Ch2)*(SensorValue(limit1 + hold)*(SensorValue(limit2);



void arm(float speed)
{
	//Assumption: Arms goes up with both motors set to positive values
	motor[armL] = speed;
	motor[armR] = speed;
}
void arm(float speedL, float speedR)
{
	//Assumption: Arms goes up with both motors set to positive values
	motor[armL] = speedL;
	motor[armR] = speedR;
}
void armX(float speed)
{
	const float k = 0.50;
	const int encDif = 2;
	int Q = (SensorValue(encL)-SensorValue(encR));

	if(Q <= encDif && Q >=-encDif)
	{
		arm(speed);
	}
	else if(Q > encDif)
	{
		if(speed >= 0)
			arm(k*speed,speed);
		else
			arm(speed,k*speed);
	}
	else
	{
		if(speed >= 0)
			arm(speed,k*speed);
		else
			arm(k*speed,speed);
	}
}

void setBottomGripper(bool open){
	SensorValue(gripperBottom) = open;
}
//?
void setTopGripper(bool open){
	topOpen = open;
}


void init()
{
	//Initialize encoders
	SensorValue(encR) = 0;
	SensorValue(encL) = 0;
	SensorValue(baseR) = 0;
	SensorValue(baseL) = 0;

	bottomOpen = false;
	topOpen = false;

	clearDebugStream();

}
void userControl()
{
	while(true){

		float hold = 15/127;

		// Movimiento de la base
		motor[rfBase]= vexRT[Ch3] - vexRT[Ch4];
		motor[rbBase]= vexRT[Ch3] - vexRT[Ch4];
		motor[lfBase]= vexRT[Ch3] + vexRT[Ch4];
		motor[lbBase]= vexRT[Ch3] + vexRT[Ch4];

		//Movimiento del double reverse
		//sube los dos brazos a la vez (verifica que pare cada uno cuando llegue a su limite CH2
		//Double Reverse LEFT/RIGHT UP/DOWN
		motor[DRLU] = vexRT(Ch2)*(SensorValue(limitDR) + hold)*SensorValue(limitArms);
		//motor[DRLD] = -vexRT(Ch2)*(SensorValue(limit1) + hold)*SensorValue(limit2);
		motor[DRRU] = vexRT(Ch2)*(SensorValue(limitDR) + hold)*SensorValue(limitArms);
		//motor[DRRD] = -vexRT(Ch2)*(SensorValue(limit1) + hold)*SensorValue(limit2);

	//	motor[armL] = 0;
	//	motor[armR] = 0;

		// Abre/cierra gripper de arriba
		if(vexRT[Btn5U])
		{
			setTopGripper(!topOpen);
		}

		// Abre/cierra gripper de abajo
		if(vexRT[Btn6U])
		{
			bottomOpen = !bottomOpen
			setBottomGripper(bottomOpen);
		}
	}
}

task moveBase
{

		SensorValue(baseL) = 0;
		SensorValue(baseR) = 0;

		const float k = 0.50;
		const int encDif = 2;
		int Q = (SensorValue(baseL)-SensorValue(baseR));

		while(SensorValue(baseL) < baseTarget){

			if(Q <= encDif && Q >=-encDif)
			{
				motor[rbBase] = baseSpeed;
				motor[rfBase] = baseSpeed;
				motor[lbBase] = baseSpeed;
				motor[lfBase] = baseSpeed;
			}
			else if(Q > encDif)
			{
				if(baseSpeed >= 0){
					motor[rbBase] = baseSpeed;
					motor[rfBase] = baseSpeed;
					motor[lbBase] = baseSpeed*k;
					motor[lfBase] = baseSpeed*k;	
				}
				else{
					motor[rbBase] = baseSpeed*k;
					motor[rfBase] = baseSpeed*k;
					motor[lbBase] = baseSpeed;
					motor[lfBase] = baseSpeed;	

				}
			}
			//moving back
			else
			{
				if(baseSpeed >= 0){
					motor[rbBase] = baseSpeed*k;
					motor[rfBase] = baseSpeed*k;
					motor[lbBase] = baseSpeed;
					motor[lfBase] = baseSpeed;
				}
				else{
					motor[rbBase] = baseSpeed;
					motor[rfBase] = baseSpeed;
					motor[lbBase] = baseSpeed*k;
					motor[lfBase] = baseSpeed*k;
				}
			}

			baseStat = SensorValue(encL) / baseTarget;
	}
	motor[rbBase] = 0;
	motor[rfBase] = 0;
	motor[lbBase] = 0;
	motor[lfBase] = 0;
}

//anadir - subir el DR tambien
task setArm{
	while(SensorValue(encR) < armTarget){
		armX(armSpeed);
		armStat = (SensorValue(encR) / armTarget);			//set el porcentaje
	}
	arm(0);
}

void BaseArm(int armT,int baseT, float armS, float baseS) {
	writeDebugStreamLine("Starting BaseArm task");
	float origArmSpeed = armS;
	float origBaseSpeed = baseS;

	armTarget = armT;
	baseTarget = baseT;
	armSpeed = armS;
	baseSpeed = baseS;

	armStat = 0;
	baseStat = 0;

	startTask(setArm);
	startTask(moveBase);

	while(armStat < 1 || baseStat < 1){
			writeDebugStreamLine("Arm Status: %f",armStat);
			writeDebugStreamLine("Base Status: %f",baseStat);
			if((armStat - baseStat) > 0.20 && (int)armSpeed == (int)origArmSpeed){
				armSpeed *= 0.50;
				writeDebugStreamLine("Arm Speed: %f",armSpeed);

			}
			else if((baseStat - armStat) > 0.20){
					baseSpeed *= 0.50;
			}
			else{
				armSpeed = origArmSpeed;
				baseSpeed = origBaseSpeed;
			}
	}
	armSpeed = 0;
	baseSpeed = 0;
	writeDebugStreamLine("Ending BaseArm task");
}


task main()
{
	//PID pidMovement;
	//PIDInit(&pidMovement, 0.15, .1, 0.25); // Set P, I, and D constants
	//pidMovResult = PIDCompute(&pidMovement, distance - encoderAvg);
	//moveBase(pidMovResult*factor);

	init();
	userControl();

}
